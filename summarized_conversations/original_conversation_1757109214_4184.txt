{'role': 'assistant', 'content': 'Now let\'s create the admin routes:\n\n<function_calls>\n<create-file file_path="angocine/backend/src/routes/admin.routes.js">\nconst express = require(\'express\');\nconst router = express.Router();\nconst db = require(\'../db\');\nconst { isAdmin } = require(\'../middleware/auth.middleware\');\n\n// Apply admin middleware to all routes\nrouter.use(isAdmin);\n\n// Get dashboard stats\nrouter.get(\'/dashboard\', async (req, res) => {\n  try {\n    // Get total users\n    const usersResult = await db.query(\'SELECT COUNT(*) as count FROM users\');\n    const totalUsers = db.USE_SQLITE ? usersResult[0].count : parseInt(usersResult[0].count);\n    \n    // Get total movies\n    const moviesResult = await db.query(\'SELECT COUNT(*) as count FROM movies\');\n    const totalMovies = db.USE_SQLITE ? moviesResult[0].count : parseInt(moviesResult[0].count);\n    \n    // Get total profiles\n    const profilesResult = await db.query(\'SELECT COUNT(*) as count FROM profiles\');\n    const totalProfiles = db.USE_SQLITE ? profilesResult[0].count : parseInt(profilesResult[0].count);\n    \n    // Get total reviews\n    const reviewsResult = await db.query(\'SELECT COUNT(*) as count FROM reviews\');\n    const totalReviews = db.USE_SQLITE ? reviewsResult[0].count : parseInt(reviewsResult[0].count);\n    \n    // Get recent users\n    const recentUsers = await db.query(`\n      SELECT id, username, email, created_at\n      FROM users\n      ORDER BY created_at DESC\n      LIMIT 5\n    `);\n    \n    // Get top rated movies\n    const topRatedMovies = await db.query(`\n      SELECT id, title, rating, release_year\n      FROM movies\n      ORDER BY rating DESC\n      LIMIT 5\n    `);\n    \n    // Get recent reviews\n    const recentReviews = await db.query(`\n      SELECT r.id, r.rating, r.comment, r.created_at, u.username, m.title as movie_title\n      FROM reviews r\n      JOIN users u ON r.user_id = u.id\n      JOIN movies m ON r.movie_id = m.id\n      ORDER BY r.created_at DESC\n      LIMIT 5\n    `);\n    \n    // Get analytics events count\n    const analyticsResult = await db.query(\'SELECT COUNT(*) as count FROM analytics_events\');\n    const totalEvents = db.USE_SQLITE ? analyticsResult[0].count : parseInt(analyticsResult[0].count);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        stats: {\n          total_users: totalUsers,\n          total_movies: totalMovies,\n          total_profiles: totalProfiles,\n          total_reviews: totalReviews,\n          total_events: totalEvents\n        },\n        recent_users: recentUsers,\n        top_rated_movies: topRatedMovies,\n        recent_reviews: recentReviews\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching admin dashboard:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching admin dashboard\' });\n  }\n});\n\n// Get all users (with pagination)\nrouter.get(\'/users\', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, search } = req.query;\n    \n    const offset = (page - 1) * limit;\n    \n    // Build query conditions\n    let conditions = [];\n    let params = [];\n    \n    if (search) {\n      conditions.push(\'(username LIKE ? OR email LIKE ?)\');\n      params.push(`%${search}%`, `%${search}%`);\n    }\n    \n    // Build WHERE clause\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(\' AND \')}` : \'\';\n    \n    // Get total count\n    const countQuery = `SELECT COUNT(*) as total FROM users ${whereClause}`;\n    const countResult = await db.query(countQuery, params);\n    const total = db.USE_SQLITE ? countResult[0].total : parseInt(countResult[0].total);\n    \n    // Get users\n    const query = `\n      SELECT id, username, email, role, created_at, updated_at\n      FROM users\n      ${whereClause}\n      ORDER BY created_at DESC\n      LIMIT ? OFFSET ?\n    `;\n    \n    const users = await db.query(query, [...params, parseInt(limit), parseInt(offset)]);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        users,\n        pagination: {\n          total,\n          page: parseInt(page),\n          limit: parseInt(limit),\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching users:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching users\' });\n  }\n});\n\n// Get user details\nrouter.get(\'/users/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Get user data\n    const users = await db.query(\'SELECT id, username, email, role, created_at, updated_at FROM users WHERE id = ?\', [id]);\n    \n    if (users.length === 0) {\n      return res.status(404).json({ error: true, message: \'User not found\' });\n    }\n    \n    const user = users[0];\n    \n    // Get user profiles\n    const profiles = await db.query(\'SELECT * FROM profiles WHERE user_id = ?\', [id]);\n    \n    // Get user reviews\n    const reviews = await db.query(`\n      SELECT r.id, r.rating, r.comment, r.created_at, m.title as movie_title\n      FROM reviews r\n      JOIN movies m ON r.movie_id = m.id\n      WHERE r.user_id = ?\n      ORDER BY r.created_at DESC\n      LIMIT 10\n    `, [id]);\n    \n    // Get watchlist count\n    const watchlistResult = await db.query(\n      \'SELECT COUNT(*) as count FROM watchlist WHERE user_id = ?\',\n      [id]\n    );\n    const watchlistCount = db.USE_SQLITE ? watchlistResult[0].count : parseInt(watchlistResult[0].count);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        user,\n        profiles,\n        reviews,\n        stats: {\n          profile_count: profiles.length,\n          review_count: reviews.length,\n          watchlist_count: watchlistCount\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching user details:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching user details\' });\n  }\n});\n\n// Update user role\nrouter.put(\'/users/:id/role\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { role } = req.body;\n    \n    // Validate role\n    if (!role || ![\'user\', \'admin\'].includes(role)) {\n      return res.status(400).json({ error: true, message: \'Invalid role\' });\n    }\n    \n    // Check if user exists\n    const users = await db.query(\'SELECT * FROM users WHERE id = ?\', [id]);\n    \n    if (users.length === 0) {\n      return res.status(404).json({ error: true, message: \'User not found\' });\n    }\n    \n    // Update role\n    await db.query(\'UPDATE users SET role = ? WHERE id = ?\', [role, id]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'User role updated successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error updating user role:\', err);\n    res.status(500).json({ error: true, message: \'Server error while updating user role\' });\n  }\n});\n\n// Delete user\nrouter.delete(\'/users/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Check if user exists\n    const users = await db.query(\'SELECT * FROM users WHERE id = ?\', [id]);\n    \n    if (users.length === 0) {\n      return res.status(404).json({ error: true, message: \'User not found\' });\n    }\n    \n    // Prevent deleting the last admin\n    if (users[0].role === \'admin\') {\n      const adminCountResult = await db.query(\'SELECT COUNT(*) as count FROM users WHERE role = ?\', [\'admin\']);\n      const adminCount = db.USE_SQLITE ? adminCountResult[0].count : parseInt(adminCountResult[0].count);\n      \n      if (adminCount <= 1) {\n        return res.status(400).json({ error: true, message: \'Cannot delete the last admin user\' });\n      }\n    }\n    \n    // Delete user (cascades to profiles, watchlist, etc.)\n    await db.query(\'DELETE FROM users WHERE id = ?\', [id]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'User deleted successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error deleting user:\', err);\n    res.status(500).json({ error: true, message: \'Server error while deleting user\' });\n  }\n});\n\n// Get all movies (with pagination)\nrouter.get(\'/movies\', async (req, res) => {\n  try {\n    const { page = 1, limit = 20, search } = req.query;\n    \n    const offset = (page - 1) * limit;\n    \n    // Build query conditions\n    let conditions = [];\n    let params = [];\n    \n    if (search) {\n      conditions.push(\'(title LIKE ? OR description LIKE ? OR director LIKE ? OR cast LIKE ?)\');\n      params.push(`%${search}%`, `%${search}%`, `%${search}%`, `%${search}%`);\n    }\n    \n    // Build WHERE clause\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(\' AND \')}` : \'\';\n    \n    // Get total count\n    const countQuery = `SELECT COUNT(*) as total FROM movies ${whereClause}`;\n    const countResult = await db.query(countQuery, params);\n    const total = db.USE_SQLITE ? countResult[0].total : parseInt(countResult[0].total);\n    \n    // Get movies\n    const query = `\n      SELECT id, title, release_year, genre, rating, language, created_at, updated_at\n      FROM movies\n      ${whereClause}\n      ORDER BY created_at DESC\n      LIMIT ? OFFSET ?\n    `;\n    \n    const movies = await db.query(query, [...params, parseInt(limit), parseInt(offset)]);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        movies,\n        pagination: {\n          total,\n          page: parseInt(page),\n          limit: parseInt(limit),\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching movies:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching movies\' });\n  }\n});\n\n// Get movie details\nrouter.get(\'/movies/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Get movie details\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [id]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    const movie = movies[0];\n    \n    // Get review count\n    const reviewCountResult = await db.query(\n      \'SELECT COUNT(*) as count FROM reviews WHERE movie_id = ?\',\n      [id]\n    );\n    const reviewCount = db.USE_SQLITE ? reviewCountResult[0].count : parseInt(reviewCountResult[0].count);\n    \n    // Get watchlist count\n    const watchlistCountResult = await db.query(\n      \'SELECT COUNT(*) as count FROM watchlist WHERE movie_id = ?\',\n      [id]\n    );\n    const watchlistCount = db.USE_SQLITE ? watchlistCountResult[0].count : parseInt(watchlistCountResult[0].count);\n    \n    // Get watch history count\n    const historyCountResult = await db.query(\n      \'SELECT COUNT(*) as count FROM watch_history WHERE movie_id = ?\',\n      [id]\n    );\n    const historyCount = db.USE_SQLITE ? historyCountResult[0].count : parseInt(historyCountResult[0].count);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        movie,\n        stats: {\n          review_count: reviewCount,\n          watchlist_count: watchlistCount,\n          history_count: historyCount\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching movie details:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching movie details\' });\n  }\n});\n\n// Create movie\nrouter.post(\'/movies\', async (req, res) => {\n  try {\n    const {\n      title, description, release_year, duration, genre, director, cast,\n      poster_url, backdrop_url, trailer_url, video_url, rating, language, maturity_rating\n    } = req.body;\n    \n    // Validate required fields\n    if (!title) {\n      return res.status(400).json({ error: true, message: \'Movie title is required\' });\n    }\n    \n    // Create movie\n    const result = await db.query(`\n      INSERT INTO movies (\n        title, description, release_year, duration, genre, director, cast,\n        poster_url, backdrop_url, trailer_url, video_url, rating, language, maturity_rating\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id\n    `, [\n      title, description || \'\', release_year || null, duration || null, genre || \'\',\n      director || \'\', cast || \'\', poster_url || \'\', backdrop_url || \'\',\n      trailer_url || \'\', video_url || \'\', rating || null, language || \'\', maturity_rating || \'\'\n    ]);\n    \n    const movieId = db.USE_SQLITE ? result[0] : result[0].id;\n    \n    // Get created movie\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [movieId]);\n    \n    res.status(201).json({\n      error: false,\n      message: \'Movie created successfully\',\n      data: { movie: movies[0] }\n    });\n  } catch (err) {\n    console.error(\'Error creating movie:\', err);\n    res.status(500).json({ error: true, message: \'Server error while creating movie\' });\n  }\n});\n\n// Update movie\nrouter.put(\'/movies/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const {\n      title, description, release_year, duration, genre, director, cast,\n      poster_url, backdrop_url, trailer_url, video_url, rating, language, maturity_rating\n    } = req.body;\n    \n    // Check if movie exists\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [id]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    // Update movie\n    const updates = [];\n    const params = [];\n    \n    if (title !== undefined) {\n      updates.push(\'title = ?\');\n      params.push(title);\n    }\n    \n    if (description !== undefined) {\n      updates.push(\'description = ?\');\n      params.push(description);\n    }\n    \n    if (release_year !== undefined) {\n      updates.push(\'release_year = ?\');\n      params.push(release_year);\n    }\n    \n    if (duration !== undefined) {\n      updates.push(\'duration = ?\');\n      params.push(duration);\n    }\n    \n    if (genre !== undefined) {\n      updates.push(\'genre = ?\');\n      params.push(genre);\n    }\n    \n    if (director !== undefined) {\n      updates.push(\'director = ?\');\n      params.push(director);\n    }\n    \n    if (cast !== undefined) {\n      updates.push(\'cast = ?\');\n      params.push(cast);\n    }\n    \n    if (poster_url !== undefined) {\n      updates.push(\'poster_url = ?\');\n      params.push(poster_url);\n    }\n    \n    if (backdrop_url !== undefined) {\n      updates.push(\'backdrop_url = ?\');\n      params.push(backdrop_url);\n    }\n    \n    if (trailer_url !== undefined) {\n      updates.push(\'trailer_url = ?\');\n      params.push(trailer_url);\n    }\n    \n    if (video_url !== undefined) {\n      updates.push(\'video_url = ?\');\n      params.push(video_url);\n    }\n    \n    if (rating !== undefined) {\n      updates.push(\'rating = ?\');\n      params.push(rating);\n    }\n    \n    if (language !== undefined) {\n      updates.push(\'language = ?\');\n      params.push(language);\n    }\n    \n    if (maturity_rating !== undefined) {\n      updates.push(\'maturity_rating = ?\');\n      params.push(maturity_rating);\n    }\n    \n    if (updates.length === 0) {\n      return res.status(400).json({ error: true, message: \'No updates provided\' });\n    }\n    \n    updates.push(\'updated_at = CURRENT_TIMESTAMP\');\n    \n    // Execute update\n    await db.query(\n      `UPDATE movies SET ${updates.join(\', \')} WHERE id = ?`,\n      [...params, id]\n    );\n    \n    // Get updated movie\n    const updatedMovies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [id]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'Movie updated successfully\',\n      data: { movie: updatedMovies[0] }\n    });\n  } catch (err) {\n    console.error(\'Error updating movie:\', err);\n    res.status(500).json({ error: true, message: \'Server error while updating movie\' });\n  }\n});\n\n// Delete movie\nrouter.delete(\'/movies/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Check if movie exists\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [id]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    // Delete movie (cascades to reviews, watchlist, history)\n    await db.query(\'DELETE FROM movies WHERE id = ?\', [id]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'Movie deleted successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error deleting movie:\', err);\n    res.status(500).json({ error: true, message: \'Server error while deleting movie\' });\n  }\n});\n\n// Get all reviews (with pagination)\nrouter.get(\'/reviews\', async (req, res) => {\n  try {\n    const { page = 1, limit = 20 } = req.query;\n    \n    const offset = (page - 1) * limit;\n    \n    // Get total count\n    const countResult = await db.query(\'SELECT COUNT(*) as total FROM reviews\');\n    const total = db.USE_SQLITE ? countResult[0].total : parseInt(countResult[0].total);\n    \n    // Get reviews\n    const reviews = await db.query(`\n      SELECT r.id, r.rating, r.comment, r.created_at,\n             u.username, u.id as user_id,\n             m.title as movie_title, m.id as movie_id\n      FROM reviews r\n      JOIN users u ON r.user_id = u.id\n      JOIN movies m ON r.movie_id = m.id\n      ORDER BY r.created_at DESC\n      LIMIT ? OFFSET ?\n    `, [parseInt(limit), parseInt(offset)]);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        reviews,\n        pagination: {\n          total,\n          page: parseInt(page),\n          limit: parseInt(limit),\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching reviews:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching reviews\' });\n  }\n});\n\n// Delete review\nrouter.delete(\'/reviews/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Check if review exists\n    const reviews = await db.query(\'SELECT * FROM reviews WHERE id = ?\', [id]);\n    \n    if (reviews.length === 0) {\n      return res.status(404).json({ error: true, message: \'Review not found\' });\n    }\n    \n    // Delete review\n    await db.query(\'DELETE FROM reviews WHERE id = ?\', [id]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'Review deleted successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error deleting review:\', err);\n    res.status(500).json({ error: true, message: \'Server error while deleting review\' });\n  }\n});\n\n// Get analytics data\nrouter.get(\'/analytics\', async (req, res) => {\n  try {\n    const { period = \'week\' } = req.query;\n    \n    let timeFilter;\n    switch (period) {\n      case \'day\':\n        timeFilter = "datetime(\'now\', \'-1 day\')";\n        break;\n      case \'week\':\n        timeFilter = "datetime(\'now\', \'-7 days\')";\n        break;\n      case \'month\':\n        timeFilter = "datetime(\'now\', \'-30 days\')";\n        break;\n      case \'year\':\n        timeFilter = "datetime(\'now\', \'-365 days\')";\n        break;\n      default:\n        timeFilter = "datetime(\'now\', \'-7 days\')";\n    }\n    \n    // Get event counts by type\n    const eventCounts = await db.query(`\n      SELECT event_type, COUNT(*) as count\n      FROM analytics_events\n      WHERE created_at >= ${timeFilter}\n      GROUP BY event_type\n      ORDER BY count DESC\n    `);\n    \n    // Get top movies by watch count\n    const topMovies = await db.query(`\n      SELECT m.id, m.title, COUNT(h.id) as watch_count\n      FROM movies m\n      JOIN watch_history h ON m.id = h.movie_id\n      WHERE h.last_watched >= ${timeFilter}\n      GROUP BY m.id, m.title\n      ORDER BY watch_count DESC\n      LIMIT 10\n    `);\n    \n    // Get user registrations over time\n    const userRegistrations = await db.query(`\n      SELECT DATE(created_at) as date, COUNT(*) as count\n      FROM users\n      WHERE created_at >= ${timeFilter}\n      GROUP BY DATE(created_at)\n      ORDER BY date\n    `);\n    \n    // Get completion rate\n    const completionRate = await db.query(`\n      SELECT \n        COUNT(CASE WHEN completed = 1 THEN 1 END) as completed_count,\n        COUNT(*) as total_count\n      FROM watch_history\n      WHERE last_watched >= ${timeFilter}\n    `);\n    \n    const rate = completionRate[0].total_count > 0 \n      ? (completionRate[0].completed_count / completionRate[0].total_count * 100).toFixed(2)\n      : 0;\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        event_counts: eventCounts,\n        top_movies: topMovies,\n        user_registrations: userRegistrations,\n        completion_rate: parseFloat(rate)\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching analytics:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching analytics\' });\n  }\n});\n\nmodule.exports = router;\n</create-file>\n</function_calls>'}