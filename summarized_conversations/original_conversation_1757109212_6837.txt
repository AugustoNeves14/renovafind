{'role': 'assistant', 'content': 'Now let\'s create the movies routes:\n\n<function_calls>\n<create-file file_path="angocine/backend/src/routes/movies.routes.js">\nconst express = require(\'express\');\nconst router = express.Router();\nconst db = require(\'../db\');\nconst { authenticateToken } = require(\'../middleware/auth.middleware\');\n\n// Get all movies with pagination and filtering\nrouter.get(\'/\', async (req, res) => {\n  try {\n    const {\n      page = 1,\n      limit = 20,\n      genre,\n      year,\n      language,\n      rating,\n      sort = \'release_year\',\n      order = \'desc\',\n      search\n    } = req.query;\n    \n    const offset = (page - 1) * limit;\n    \n    // Build query conditions\n    let conditions = [];\n    let params = [];\n    \n    if (genre) {\n      conditions.push(\'genre LIKE ?\');\n      params.push(`%${genre}%`);\n    }\n    \n    if (year) {\n      conditions.push(\'release_year = ?\');\n      params.push(year);\n    }\n    \n    if (language) {\n      conditions.push(\'language = ?\');\n      params.push(language);\n    }\n    \n    if (rating) {\n      conditions.push(\'rating >= ?\');\n      params.push(rating);\n    }\n    \n    if (search) {\n      conditions.push(\'(title LIKE ? OR description LIKE ? OR director LIKE ? OR cast LIKE ?)\');\n      params.push(`%${search}%`, `%${search}%`, `%${search}%`, `%${search}%`);\n    }\n    \n    // Build WHERE clause\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(\' AND \')}` : \'\';\n    \n    // Validate sort field to prevent SQL injection\n    const validSortFields = [\'title\', \'release_year\', \'rating\', \'duration\'];\n    const sortField = validSortFields.includes(sort) ? sort : \'release_year\';\n    \n    // Validate order\n    const sortOrder = order.toLowerCase() === \'asc\' ? \'ASC\' : \'DESC\';\n    \n    // Get total count\n    const countQuery = `SELECT COUNT(*) as total FROM movies ${whereClause}`;\n    const countResult = await db.query(countQuery, params);\n    const total = db.USE_SQLITE ? countResult[0].total : parseInt(countResult[0].total);\n    \n    // Get movies\n    const query = `\n      SELECT id, title, description, release_year, duration, genre, director,\n             poster_url, backdrop_url, rating, language, maturity_rating\n      FROM movies\n      ${whereClause}\n      ORDER BY ${sortField} ${sortOrder}\n      LIMIT ? OFFSET ?\n    `;\n    \n    const movies = await db.query(query, [...params, parseInt(limit), parseInt(offset)]);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        movies,\n        pagination: {\n          total,\n          page: parseInt(page),\n          limit: parseInt(limit),\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching movies:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching movies\' });\n  }\n});\n\n// Get movie by ID\nrouter.get(\'/:id\', async (req, res) => {\n  try {\n    const { id } = req.params;\n    \n    // Get movie details\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [id]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    const movie = movies[0];\n    \n    // Get reviews\n    const reviews = await db.query(`\n      SELECT r.id, r.rating, r.comment, r.created_at, u.username\n      FROM reviews r\n      JOIN users u ON r.user_id = u.id\n      WHERE r.movie_id = ?\n      ORDER BY r.created_at DESC\n      LIMIT 10\n    `, [id]);\n    \n    // Get average rating\n    const ratingResult = await db.query(`\n      SELECT AVG(rating) as average_rating, COUNT(*) as total_reviews\n      FROM reviews\n      WHERE movie_id = ?\n    `, [id]);\n    \n    const averageRating = ratingResult[0].average_rating || movie.rating;\n    const totalReviews = ratingResult[0].total_reviews || 0;\n    \n    // Get similar movies based on genre\n    const similarMovies = await db.query(`\n      SELECT id, title, poster_url, release_year, rating\n      FROM movies\n      WHERE genre LIKE ? AND id != ?\n      ORDER BY rating DESC\n      LIMIT 6\n    `, [`%${movie.genre.split(\',\')[0].trim()}%`, id]);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        movie,\n        reviews,\n        ratings: {\n          average: parseFloat(averageRating).toFixed(1),\n          total: totalReviews\n        },\n        similar_movies: similarMovies\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching movie details:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching movie details\' });\n  }\n});\n\n// Get movie genres (for filters)\nrouter.get(\'/filters/genres\', async (req, res) => {\n  try {\n    const movies = await db.query(\'SELECT DISTINCT genre FROM movies\');\n    \n    // Extract and flatten genres\n    const genreSet = new Set();\n    movies.forEach(movie => {\n      if (movie.genre) {\n        movie.genre.split(\',\').forEach(g => {\n          genreSet.add(g.trim());\n        });\n      }\n    });\n    \n    const genres = Array.from(genreSet).sort();\n    \n    res.status(200).json({\n      error: false,\n      data: { genres }\n    });\n  } catch (err) {\n    console.error(\'Error fetching genres:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching genres\' });\n  }\n});\n\n// Get movie languages (for filters)\nrouter.get(\'/filters/languages\', async (req, res) => {\n  try {\n    const movies = await db.query(\'SELECT DISTINCT language FROM movies\');\n    \n    // Extract languages\n    const languages = movies.map(movie => movie.language).filter(Boolean).sort();\n    \n    res.status(200).json({\n      error: false,\n      data: { languages }\n    });\n  } catch (err) {\n    console.error(\'Error fetching languages:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching languages\' });\n  }\n});\n\n// Get movie years (for filters)\nrouter.get(\'/filters/years\', async (req, res) => {\n  try {\n    const movies = await db.query(\'SELECT DISTINCT release_year FROM movies ORDER BY release_year DESC\');\n    \n    // Extract years\n    const years = movies.map(movie => movie.release_year).filter(Boolean);\n    \n    res.status(200).json({\n      error: false,\n      data: { years }\n    });\n  } catch (err) {\n    console.error(\'Error fetching years:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching years\' });\n  }\n});\n\n// Add review to movie (requires authentication)\nrouter.post(\'/:id/reviews\', authenticateToken, async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { rating, comment } = req.body;\n    const userId = req.user.id;\n    \n    // Validate input\n    if (!rating || rating < 1 || rating > 5) {\n      return res.status(400).json({ error: true, message: \'Rating must be between 1 and 5\' });\n    }\n    \n    // Check if movie exists\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [id]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    // Check if user already reviewed this movie\n    const existingReviews = await db.query(\n      \'SELECT * FROM reviews WHERE user_id = ? AND movie_id = ?\',\n      [userId, id]\n    );\n    \n    if (existingReviews.length > 0) {\n      // Update existing review\n      await db.query(\n        \'UPDATE reviews SET rating = ?, comment = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ? AND movie_id = ?\',\n        [rating, comment || \'\', userId, id]\n      );\n      \n      res.status(200).json({\n        error: false,\n        message: \'Review updated successfully\'\n      });\n    } else {\n      // Create new review\n      await db.query(\n        \'INSERT INTO reviews (user_id, movie_id, rating, comment) VALUES (?, ?, ?, ?)\',\n        [userId, id, rating, comment || \'\']\n      );\n      \n      res.status(201).json({\n        error: false,\n        message: \'Review added successfully\'\n      });\n    }\n  } catch (err) {\n    console.error(\'Error adding review:\', err);\n    res.status(500).json({ error: true, message: \'Server error while adding review\' });\n  }\n});\n\n// Search movies\nrouter.get(\'/search/query\', async (req, res) => {\n  try {\n    const { q, limit = 10 } = req.query;\n    \n    if (!q) {\n      return res.status(400).json({ error: true, message: \'Search query is required\' });\n    }\n    \n    const query = `\n      SELECT id, title, poster_url, release_year, genre\n      FROM movies\n      WHERE title LIKE ? OR description LIKE ? OR director LIKE ? OR cast LIKE ?\n      LIMIT ?\n    `;\n    \n    const searchTerm = `%${q}%`;\n    const movies = await db.query(query, [searchTerm, searchTerm, searchTerm, searchTerm, parseInt(limit)]);\n    \n    res.status(200).json({\n      error: false,\n      data: { movies }\n    });\n  } catch (err) {\n    console.error(\'Error searching movies:\', err);\n    res.status(500).json({ error: true, message: \'Server error while searching movies\' });\n  }\n});\n\nmodule.exports = router;\n</create-file>\n</function_calls>'}