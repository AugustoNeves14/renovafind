{'role': 'assistant', 'content': 'Let\'s create the video player component:\n\n<function_calls>\n<create-file file_path="angocine/frontend/angocine/src/app/components/video-player/video-player.component.ts">\nimport { Component, OnInit, Input, ViewChild, ElementRef, OnDestroy, Output, EventEmitter } from \'@angular/core\';\nimport * as Hls from \'hls.js\';\n\n@Component({\n  selector: \'app-video-player\',\n  templateUrl: \'./video-player.component.html\',\n  styleUrls: [\'./video-player.component.scss\']\n})\nexport class VideoPlayerComponent implements OnInit, OnDestroy {\n  @Input() videoUrl: string = \'\';\n  @Input() autoplay: boolean = false;\n  @Input() poster: string = \'\';\n  @Input() title: string = \'\';\n  @Input() subtitles: { src: string, label: string, srclang: string }[] = [];\n  \n  @Output() timeUpdate = new EventEmitter<number>();\n  @Output() videoEnded = new EventEmitter<void>();\n  @Output() videoStarted = new EventEmitter<void>();\n  \n  @ViewChild(\'videoPlayer\') videoPlayerRef!: ElementRef<HTMLVideoElement>;\n  \n  isPlaying: boolean = false;\n  isMuted: boolean = false;\n  isFullscreen: boolean = false;\n  isPipActive: boolean = false;\n  showControls: boolean = true;\n  controlsTimeout: any;\n  volume: number = 1;\n  currentTime: number = 0;\n  duration: number = 0;\n  buffered: number = 0;\n  isLoading: boolean = true;\n  showSettings: boolean = false;\n  playbackRates: number[] = [0.5, 0.75, 1, 1.25, 1.5, 2];\n  currentPlaybackRate: number = 1;\n  currentQuality: string = \'auto\';\n  qualities: string[] = [\'auto\', \'1080p\', \'720p\', \'480p\', \'360p\'];\n  \n  private hls: Hls | null = null;\n  \n  constructor() {}\n  \n  ngOnInit(): void {\n    // Initialize player when component is ready\n    setTimeout(() => {\n      this.initializePlayer();\n    });\n  }\n  \n  ngOnDestroy(): void {\n    this.destroyPlayer();\n  }\n  \n  private initializePlayer(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    \n    // Check if HLS is supported\n    if (Hls.isSupported() && this.isHlsStream(this.videoUrl)) {\n      this.hls = new Hls();\n      this.hls.loadSource(this.videoUrl);\n      this.hls.attachMedia(video);\n      \n      this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\n        if (this.autoplay) {\n          video.play().catch(() => {\n            console.log(\'Autoplay prevented by browser\');\n          });\n        }\n        this.isLoading = false;\n      });\n      \n      this.hls.on(Hls.Events.ERROR, (event, data) => {\n        console.error(\'HLS error:\', data);\n        if (data.fatal) {\n          switch (data.type) {\n            case Hls.ErrorTypes.NETWORK_ERROR:\n              console.log(\'Network error, trying to recover...\');\n              this.hls?.startLoad();\n              break;\n            case Hls.ErrorTypes.MEDIA_ERROR:\n              console.log(\'Media error, trying to recover...\');\n              this.hls?.recoverMediaError();\n              break;\n            default:\n              this.destroyPlayer();\n              break;\n          }\n        }\n      });\n    } else if (video.canPlayType(\'application/vnd.apple.mpegurl\')) {\n      // For Safari which has built-in HLS support\n      video.src = this.videoUrl;\n      video.addEventListener(\'loadedmetadata\', () => {\n        if (this.autoplay) {\n          video.play().catch(() => {\n            console.log(\'Autoplay prevented by browser\');\n          });\n        }\n        this.isLoading = false;\n      });\n    } else {\n      // Fallback for other browsers\n      video.src = this.videoUrl;\n      if (this.autoplay) {\n        video.play().catch(() => {\n          console.log(\'Autoplay prevented by browser\');\n        });\n      }\n      this.isLoading = false;\n    }\n    \n    // Add event listeners\n    video.addEventListener(\'timeupdate\', this.onTimeUpdate.bind(this));\n    video.addEventListener(\'durationchange\', this.onDurationChange.bind(this));\n    video.addEventListener(\'progress\', this.onProgress.bind(this));\n    video.addEventListener(\'ended\', this.onEnded.bind(this));\n    video.addEventListener(\'play\', this.onPlay.bind(this));\n    video.addEventListener(\'pause\', this.onPause.bind(this));\n    video.addEventListener(\'waiting\', () => { this.isLoading = true; });\n    video.addEventListener(\'canplay\', () => { this.isLoading = false; });\n    \n    // Add subtitles if available\n    this.addSubtitles();\n  }\n  \n  private destroyPlayer(): void {\n    if (this.hls) {\n      this.hls.destroy();\n      this.hls = null;\n    }\n    \n    const video = this.videoPlayerRef?.nativeElement;\n    if (video) {\n      video.removeEventListener(\'timeupdate\', this.onTimeUpdate);\n      video.removeEventListener(\'durationchange\', this.onDurationChange);\n      video.removeEventListener(\'progress\', this.onProgress);\n      video.removeEventListener(\'ended\', this.onEnded);\n      video.removeEventListener(\'play\', this.onPlay);\n      video.removeEventListener(\'pause\', this.onPause);\n    }\n  }\n  \n  private isHlsStream(url: string): boolean {\n    return url.includes(\'.m3u8\');\n  }\n  \n  private addSubtitles(): void {\n    if (!this.subtitles.length) return;\n    \n    const video = this.videoPlayerRef.nativeElement;\n    \n    // Remove existing tracks\n    while (video.firstChild) {\n      video.removeChild(video.firstChild);\n    }\n    \n    // Add new tracks\n    this.subtitles.forEach(subtitle => {\n      const track = document.createElement(\'track\');\n      track.kind = \'subtitles\';\n      track.label = subtitle.label;\n      track.srclang = subtitle.srclang;\n      track.src = subtitle.src;\n      \n      video.appendChild(track);\n    });\n  }\n  \n  // Event handlers\n  private onTimeUpdate(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    this.currentTime = video.currentTime;\n    this.timeUpdate.emit(this.currentTime);\n  }\n  \n  private onDurationChange(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    this.duration = video.duration;\n  }\n  \n  private onProgress(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    if (video.buffered.length > 0) {\n      this.buffered = video.buffered.end(video.buffered.length - 1);\n    }\n  }\n  \n  private onEnded(): void {\n    this.isPlaying = false;\n    this.videoEnded.emit();\n  }\n  \n  private onPlay(): void {\n    this.isPlaying = true;\n    this.videoStarted.emit();\n  }\n  \n  private onPause(): void {\n    this.isPlaying = false;\n  }\n  \n  // Control methods\n  togglePlay(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    if (this.isPlaying) {\n      video.pause();\n    } else {\n      video.play().catch(error => {\n        console.error(\'Error playing video:\', error);\n      });\n    }\n    this.resetControlsTimeout();\n  }\n  \n  toggleMute(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    video.muted = !video.muted;\n    this.isMuted = video.muted;\n    this.resetControlsTimeout();\n  }\n  \n  setVolume(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const video = this.videoPlayerRef.nativeElement;\n    this.volume = parseFloat(input.value);\n    video.volume = this.volume;\n    video.muted = this.volume === 0;\n    this.isMuted = video.muted;\n    this.resetControlsTimeout();\n  }\n  \n  seek(event: Event): void {\n    const input = event.target as HTMLInputElement;\n    const video = this.videoPlayerRef.nativeElement;\n    const seekTime = parseFloat(input.value);\n    video.currentTime = seekTime;\n    this.resetControlsTimeout();\n  }\n  \n  seekByClick(event: MouseEvent): void {\n    const progressBar = event.currentTarget as HTMLElement;\n    const rect = progressBar.getBoundingClientRect();\n    const percent = (event.clientX - rect.left) / rect.width;\n    const video = this.videoPlayerRef.nativeElement;\n    video.currentTime = percent * video.duration;\n    this.resetControlsTimeout();\n  }\n  \n  toggleFullscreen(): void {\n    const container = document.querySelector(\'.video-player-container\') as HTMLElement;\n    \n    if (!document.fullscreenElement) {\n      if (container.requestFullscreen) {\n        container.requestFullscreen();\n      } else if ((container as any).webkitRequestFullscreen) {\n        (container as any).webkitRequestFullscreen();\n      } else if ((container as any).msRequestFullscreen) {\n        (container as any).msRequestFullscreen();\n      }\n      this.isFullscreen = true;\n    } else {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if ((document as any).webkitExitFullscreen) {\n        (document as any).webkitExitFullscreen();\n      } else if ((document as any).msExitFullscreen) {\n        (document as any).msExitFullscreen();\n      }\n      this.isFullscreen = false;\n    }\n    \n    this.resetControlsTimeout();\n  }\n  \n  togglePictureInPicture(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    \n    if (document.pictureInPictureElement) {\n      document.exitPictureInPicture();\n      this.isPipActive = false;\n    } else if (document.pictureInPictureEnabled) {\n      video.requestPictureInPicture();\n      this.isPipActive = true;\n    }\n    \n    this.resetControlsTimeout();\n  }\n  \n  setPlaybackRate(rate: number): void {\n    const video = this.videoPlayerRef.nativeElement;\n    video.playbackRate = rate;\n    this.currentPlaybackRate = rate;\n    this.showSettings = false;\n    this.resetControlsTimeout();\n  }\n  \n  setQuality(quality: string): void {\n    // This would be implemented with HLS.js quality switching\n    // For now, just update the UI\n    this.currentQuality = quality;\n    this.showSettings = false;\n    this.resetControlsTimeout();\n  }\n  \n  toggleSettings(): void {\n    this.showSettings = !this.showSettings;\n    this.resetControlsTimeout();\n  }\n  \n  // Helper methods\n  formatTime(seconds: number): string {\n    if (isNaN(seconds)) return \'00:00\';\n    \n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = Math.floor(seconds % 60);\n    \n    if (h > 0) {\n      return `${h.toString().padStart(2, \'0\')}:${m.toString().padStart(2, \'0\')}:${s.toString().padStart(2, \'0\')}`;\n    } else {\n      return `${m.toString().padStart(2, \'0\')}:${s.toString().padStart(2, \'0\')}`;\n    }\n  }\n  \n  onMouseMove(): void {\n    this.showControls = true;\n    this.resetControlsTimeout();\n  }\n  \n  resetControlsTimeout(): void {\n    clearTimeout(this.controlsTimeout);\n    this.showControls = true;\n    \n    this.controlsTimeout = setTimeout(() => {\n      if (this.isPlaying && !this.showSettings) {\n        this.showControls = false;\n      }\n    }, 3000);\n  }\n  \n  getBufferedPercent(): number {\n    return (this.buffered / this.duration) * 100 || 0;\n  }\n  \n  getCurrentPercent(): number {\n    return (this.currentTime / this.duration) * 100 || 0;\n  }\n  \n  forward10(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    video.currentTime = Math.min(video.currentTime + 10, video.duration);\n    this.resetControlsTimeout();\n  }\n  \n  rewind10(): void {\n    const video = this.videoPlayerRef.nativeElement;\n    video.currentTime = Math.max(video.currentTime - 10, 0);\n    this.resetControlsTimeout();\n  }\n}\n</create-file>\n</function_calls>'}