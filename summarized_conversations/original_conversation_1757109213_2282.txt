{'role': 'assistant', 'content': 'Now let\'s create the user routes:\n\n<function_calls>\n<create-file file_path="angocine/backend/src/routes/user.routes.js">\nconst express = require(\'express\');\nconst router = express.Router();\nconst db = require(\'../db\');\nconst bcrypt = require(\'bcryptjs\');\n\n// Get user profile\nrouter.get(\'/profile\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    \n    // Get user data\n    const users = await db.query(\'SELECT id, username, email, role FROM users WHERE id = ?\', [userId]);\n    \n    if (users.length === 0) {\n      return res.status(404).json({ error: true, message: \'User not found\' });\n    }\n    \n    const user = users[0];\n    \n    // Get user profiles\n    const profiles = await db.query(\'SELECT * FROM profiles WHERE user_id = ?\', [userId]);\n    \n    // Get watchlist count\n    const watchlistResult = await db.query(\n      \'SELECT COUNT(*) as count FROM watchlist WHERE user_id = ?\',\n      [userId]\n    );\n    const watchlistCount = db.USE_SQLITE ? watchlistResult[0].count : parseInt(watchlistResult[0].count);\n    \n    // Get history count\n    const historyResult = await db.query(`\n      SELECT COUNT(DISTINCT movie_id) as count \n      FROM watch_history \n      WHERE profile_id IN (SELECT id FROM profiles WHERE user_id = ?)\n    `, [userId]);\n    const historyCount = db.USE_SQLITE ? historyResult[0].count : parseInt(historyResult[0].count);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        user,\n        profiles,\n        stats: {\n          watchlist_count: watchlistCount,\n          history_count: historyCount\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching user profile:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching user profile\' });\n  }\n});\n\n// Update user profile\nrouter.put(\'/profile\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { username, email, current_password, new_password } = req.body;\n    \n    // Get current user data\n    const users = await db.query(\'SELECT * FROM users WHERE id = ?\', [userId]);\n    \n    if (users.length === 0) {\n      return res.status(404).json({ error: true, message: \'User not found\' });\n    }\n    \n    const user = users[0];\n    \n    // Check if email is already taken by another user\n    if (email && email !== user.email) {\n      const existingUsers = await db.query(\'SELECT * FROM users WHERE email = ? AND id != ?\', [email, userId]);\n      \n      if (existingUsers.length > 0) {\n        return res.status(409).json({ error: true, message: \'Email already in use\' });\n      }\n    }\n    \n    // Check if username is already taken by another user\n    if (username && username !== user.username) {\n      const existingUsers = await db.query(\'SELECT * FROM users WHERE username = ? AND id != ?\', [username, userId]);\n      \n      if (existingUsers.length > 0) {\n        return res.status(409).json({ error: true, message: \'Username already in use\' });\n      }\n    }\n    \n    // Update user data\n    const updates = [];\n    const params = [];\n    \n    if (username) {\n      updates.push(\'username = ?\');\n      params.push(username);\n    }\n    \n    if (email) {\n      updates.push(\'email = ?\');\n      params.push(email);\n    }\n    \n    // If password change is requested\n    if (current_password && new_password) {\n      // Verify current password\n      const validPassword = await bcrypt.compare(current_password, user.password);\n      \n      if (!validPassword) {\n        return res.status(400).json({ error: true, message: \'Current password is incorrect\' });\n      }\n      \n      // Hash new password\n      const salt = await bcrypt.genSalt(10);\n      const hashedPassword = await bcrypt.hash(new_password, salt);\n      \n      updates.push(\'password = ?\');\n      params.push(hashedPassword);\n    }\n    \n    if (updates.length === 0) {\n      return res.status(400).json({ error: true, message: \'No updates provided\' });\n    }\n    \n    updates.push(\'updated_at = CURRENT_TIMESTAMP\');\n    \n    // Execute update\n    await db.query(\n      `UPDATE users SET ${updates.join(\', \')} WHERE id = ?`,\n      [...params, userId]\n    );\n    \n    res.status(200).json({\n      error: false,\n      message: \'Profile updated successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error updating user profile:\', err);\n    res.status(500).json({ error: true, message: \'Server error while updating user profile\' });\n  }\n});\n\n// Get user profiles\nrouter.get(\'/profiles\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    \n    // Get profiles\n    const profiles = await db.query(\'SELECT * FROM profiles WHERE user_id = ?\', [userId]);\n    \n    res.status(200).json({\n      error: false,\n      data: { profiles }\n    });\n  } catch (err) {\n    console.error(\'Error fetching user profiles:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching user profiles\' });\n  }\n});\n\n// Create new profile\nrouter.post(\'/profiles\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { name, avatar, is_kid } = req.body;\n    \n    // Validate input\n    if (!name) {\n      return res.status(400).json({ error: true, message: \'Profile name is required\' });\n    }\n    \n    // Check profile limit (max 5 profiles per user)\n    const profilesResult = await db.query(\n      \'SELECT COUNT(*) as count FROM profiles WHERE user_id = ?\',\n      [userId]\n    );\n    const profileCount = db.USE_SQLITE ? profilesResult[0].count : parseInt(profilesResult[0].count);\n    \n    if (profileCount >= 5) {\n      return res.status(400).json({ error: true, message: \'Maximum profile limit reached (5)\' });\n    }\n    \n    // Create profile\n    const result = await db.query(\n      \'INSERT INTO profiles (user_id, name, avatar, is_kid) VALUES (?, ?, ?, ?) RETURNING id\',\n      [userId, name, avatar || `https://i.pravatar.cc/150?u=${Date.now()}`, is_kid ? 1 : 0]\n    );\n    \n    const profileId = db.USE_SQLITE ? result[0] : result[0].id;\n    \n    // Get created profile\n    const profiles = await db.query(\'SELECT * FROM profiles WHERE id = ?\', [profileId]);\n    \n    res.status(201).json({\n      error: false,\n      message: \'Profile created successfully\',\n      data: { profile: profiles[0] }\n    });\n  } catch (err) {\n    console.error(\'Error creating profile:\', err);\n    res.status(500).json({ error: true, message: \'Server error while creating profile\' });\n  }\n});\n\n// Update profile\nrouter.put(\'/profiles/:id\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const profileId = req.params.id;\n    const { name, avatar, is_kid } = req.body;\n    \n    // Check if profile exists and belongs to user\n    const profiles = await db.query(\n      \'SELECT * FROM profiles WHERE id = ? AND user_id = ?\',\n      [profileId, userId]\n    );\n    \n    if (profiles.length === 0) {\n      return res.status(404).json({ error: true, message: \'Profile not found or access denied\' });\n    }\n    \n    // Update profile\n    const updates = [];\n    const params = [];\n    \n    if (name) {\n      updates.push(\'name = ?\');\n      params.push(name);\n    }\n    \n    if (avatar) {\n      updates.push(\'avatar = ?\');\n      params.push(avatar);\n    }\n    \n    if (is_kid !== undefined) {\n      updates.push(\'is_kid = ?\');\n      params.push(is_kid ? 1 : 0);\n    }\n    \n    if (updates.length === 0) {\n      return res.status(400).json({ error: true, message: \'No updates provided\' });\n    }\n    \n    updates.push(\'updated_at = CURRENT_TIMESTAMP\');\n    \n    // Execute update\n    await db.query(\n      `UPDATE profiles SET ${updates.join(\', \')} WHERE id = ?`,\n      [...params, profileId]\n    );\n    \n    // Get updated profile\n    const updatedProfiles = await db.query(\'SELECT * FROM profiles WHERE id = ?\', [profileId]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'Profile updated successfully\',\n      data: { profile: updatedProfiles[0] }\n    });\n  } catch (err) {\n    console.error(\'Error updating profile:\', err);\n    res.status(500).json({ error: true, message: \'Server error while updating profile\' });\n  }\n});\n\n// Delete profile\nrouter.delete(\'/profiles/:id\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const profileId = req.params.id;\n    \n    // Check if profile exists and belongs to user\n    const profiles = await db.query(\n      \'SELECT * FROM profiles WHERE id = ? AND user_id = ?\',\n      [profileId, userId]\n    );\n    \n    if (profiles.length === 0) {\n      return res.status(404).json({ error: true, message: \'Profile not found or access denied\' });\n    }\n    \n    // Check if it\'s the last profile\n    const profilesResult = await db.query(\n      \'SELECT COUNT(*) as count FROM profiles WHERE user_id = ?\',\n      [userId]\n    );\n    const profileCount = db.USE_SQLITE ? profilesResult[0].count : parseInt(profilesResult[0].count);\n    \n    if (profileCount <= 1) {\n      return res.status(400).json({ error: true, message: \'Cannot delete the last profile\' });\n    }\n    \n    // Delete profile\n    await db.query(\'DELETE FROM profiles WHERE id = ?\', [profileId]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'Profile deleted successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error deleting profile:\', err);\n    res.status(500).json({ error: true, message: \'Server error while deleting profile\' });\n  }\n});\n\n// Get user watchlist\nrouter.get(\'/watchlist\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { page = 1, limit = 20 } = req.query;\n    \n    const offset = (page - 1) * limit;\n    \n    // Get total count\n    const countResult = await db.query(\n      \'SELECT COUNT(*) as total FROM watchlist WHERE user_id = ?\',\n      [userId]\n    );\n    const total = db.USE_SQLITE ? countResult[0].total : parseInt(countResult[0].total);\n    \n    // Get watchlist items with movie details\n    const watchlist = await db.query(`\n      SELECT m.id, m.title, m.poster_url, m.backdrop_url, m.release_year, m.rating, m.genre, w.added_at\n      FROM watchlist w\n      JOIN movies m ON w.movie_id = m.id\n      WHERE w.user_id = ?\n      ORDER BY w.added_at DESC\n      LIMIT ? OFFSET ?\n    `, [userId, parseInt(limit), parseInt(offset)]);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        watchlist,\n        pagination: {\n          total,\n          page: parseInt(page),\n          limit: parseInt(limit),\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching watchlist:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching watchlist\' });\n  }\n});\n\n// Add movie to watchlist\nrouter.post(\'/watchlist/:movieId\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { movieId } = req.params;\n    \n    // Check if movie exists\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [movieId]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    // Check if movie is already in watchlist\n    const existingItems = await db.query(\n      \'SELECT * FROM watchlist WHERE user_id = ? AND movie_id = ?\',\n      [userId, movieId]\n    );\n    \n    if (existingItems.length > 0) {\n      return res.status(409).json({ error: true, message: \'Movie already in watchlist\' });\n    }\n    \n    // Add to watchlist\n    await db.query(\n      \'INSERT INTO watchlist (user_id, movie_id) VALUES (?, ?)\',\n      [userId, movieId]\n    );\n    \n    res.status(201).json({\n      error: false,\n      message: \'Movie added to watchlist\'\n    });\n  } catch (err) {\n    console.error(\'Error adding to watchlist:\', err);\n    res.status(500).json({ error: true, message: \'Server error while adding to watchlist\' });\n  }\n});\n\n// Remove movie from watchlist\nrouter.delete(\'/watchlist/:movieId\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { movieId } = req.params;\n    \n    // Remove from watchlist\n    await db.query(\n      \'DELETE FROM watchlist WHERE user_id = ? AND movie_id = ?\',\n      [userId, movieId]\n    );\n    \n    res.status(200).json({\n      error: false,\n      message: \'Movie removed from watchlist\'\n    });\n  } catch (err) {\n    console.error(\'Error removing from watchlist:\', err);\n    res.status(500).json({ error: true, message: \'Server error while removing from watchlist\' });\n  }\n});\n\n// Check if movie is in watchlist\nrouter.get(\'/watchlist/check/:movieId\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { movieId } = req.params;\n    \n    // Check watchlist\n    const items = await db.query(\n      \'SELECT * FROM watchlist WHERE user_id = ? AND movie_id = ?\',\n      [userId, movieId]\n    );\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        in_watchlist: items.length > 0\n      }\n    });\n  } catch (err) {\n    console.error(\'Error checking watchlist:\', err);\n    res.status(500).json({ error: true, message: \'Server error while checking watchlist\' });\n  }\n});\n\n// Get watch history for a profile\nrouter.get(\'/history/:profileId\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { profileId } = req.params;\n    const { page = 1, limit = 20 } = req.query;\n    \n    const offset = (page - 1) * limit;\n    \n    // Check if profile belongs to user\n    const profiles = await db.query(\n      \'SELECT * FROM profiles WHERE id = ? AND user_id = ?\',\n      [profileId, userId]\n    );\n    \n    if (profiles.length === 0) {\n      return res.status(404).json({ error: true, message: \'Profile not found or access denied\' });\n    }\n    \n    // Get total count\n    const countResult = await db.query(\n      \'SELECT COUNT(*) as total FROM watch_history WHERE profile_id = ?\',\n      [profileId]\n    );\n    const total = db.USE_SQLITE ? countResult[0].total : parseInt(countResult[0].total);\n    \n    // Get history items with movie details\n    const history = await db.query(`\n      SELECT \n        h.id, h.movie_id, h.watch_time, h.completed, h.last_watched,\n        m.title, m.poster_url, m.backdrop_url, m.duration, m.release_year\n      FROM watch_history h\n      JOIN movies m ON h.movie_id = m.id\n      WHERE h.profile_id = ?\n      ORDER BY h.last_watched DESC\n      LIMIT ? OFFSET ?\n    `, [profileId, parseInt(limit), parseInt(offset)]);\n    \n    // Calculate progress for each item\n    const historyWithProgress = history.map(item => {\n      const progress = item.duration > 0 ? Math.min(100, Math.round((item.watch_time / (item.duration * 60)) * 100)) : 0;\n      return {\n        ...item,\n        progress\n      };\n    });\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        history: historyWithProgress,\n        pagination: {\n          total,\n          page: parseInt(page),\n          limit: parseInt(limit),\n          pages: Math.ceil(total / limit)\n        }\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching watch history:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching watch history\' });\n  }\n});\n\n// Update watch history\nrouter.post(\'/history/:profileId/:movieId\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { profileId, movieId } = req.params;\n    const { watch_time, completed } = req.body;\n    \n    // Check if profile belongs to user\n    const profiles = await db.query(\n      \'SELECT * FROM profiles WHERE id = ? AND user_id = ?\',\n      [profileId, userId]\n    );\n    \n    if (profiles.length === 0) {\n      return res.status(404).json({ error: true, message: \'Profile not found or access denied\' });\n    }\n    \n    // Check if movie exists\n    const movies = await db.query(\'SELECT * FROM movies WHERE id = ?\', [movieId]);\n    \n    if (movies.length === 0) {\n      return res.status(404).json({ error: true, message: \'Movie not found\' });\n    }\n    \n    // Check if history entry exists\n    const historyItems = await db.query(\n      \'SELECT * FROM watch_history WHERE profile_id = ? AND movie_id = ?\',\n      [profileId, movieId]\n    );\n    \n    if (historyItems.length > 0) {\n      // Update existing entry\n      await db.query(`\n        UPDATE watch_history \n        SET watch_time = ?, completed = ?, last_watched = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP\n        WHERE profile_id = ? AND movie_id = ?\n      `, [watch_time, completed ? 1 : 0, profileId, movieId]);\n    } else {\n      // Create new entry\n      await db.query(`\n        INSERT INTO watch_history (profile_id, movie_id, watch_time, completed)\n        VALUES (?, ?, ?, ?)\n      `, [profileId, movieId, watch_time, completed ? 1 : 0]);\n    }\n    \n    // Record analytics event\n    await db.query(`\n      INSERT INTO analytics_events (profile_id, movie_id, event_type, event_data)\n      VALUES (?, ?, ?, ?)\n    `, [\n      profileId, \n      movieId, \n      completed ? \'movie_completed\' : \'movie_progress\',\n      JSON.stringify({ watch_time, completed: completed ? 1 : 0 })\n    ]);\n    \n    res.status(200).json({\n      error: false,\n      message: \'Watch history updated successfully\'\n    });\n  } catch (err) {\n    console.error(\'Error updating watch history:\', err);\n    res.status(500).json({ error: true, message: \'Server error while updating watch history\' });\n  }\n});\n\n// Get recommendations for a profile\nrouter.get(\'/recommendations/:profileId\', async (req, res) => {\n  try {\n    const userId = req.user.id;\n    const { profileId } = req.params;\n    const { limit = 10 } = req.query;\n    \n    // Check if profile belongs to user\n    const profiles = await db.query(\n      \'SELECT * FROM profiles WHERE id = ? AND user_id = ?\',\n      [profileId, userId]\n    );\n    \n    if (profiles.length === 0) {\n      return res.status(404).json({ error: true, message: \'Profile not found or access denied\' });\n    }\n    \n    // Get watched genres\n    const watchedGenres = await db.query(`\n      SELECT DISTINCT m.genre\n      FROM watch_history h\n      JOIN movies m ON h.movie_id = m.id\n      WHERE h.profile_id = ?\n      LIMIT 5\n    `, [profileId]);\n    \n    // If no watch history, return top rated movies\n    if (watchedGenres.length === 0) {\n      const topRated = await db.query(`\n        SELECT id, title, poster_url, backdrop_url, release_year, rating, genre\n        FROM movies\n        ORDER BY rating DESC\n        LIMIT ?\n      `, [parseInt(limit)]);\n      \n      return res.status(200).json({\n        error: false,\n        data: {\n          recommendations: topRated,\n          based_on: \'top_rated\'\n        }\n      });\n    }\n    \n    // Extract genres and create search conditions\n    const genres = [];\n    watchedGenres.forEach(item => {\n      if (item.genre) {\n        item.genre.split(\',\').forEach(g => {\n          genres.push(g.trim());\n        });\n      }\n    });\n    \n    // Get watched movie IDs to exclude\n    const watchedMovies = await db.query(`\n      SELECT movie_id\n      FROM watch_history\n      WHERE profile_id = ?\n    `, [profileId]);\n    \n    const watchedIds = watchedMovies.map(item => item.movie_id);\n    \n    // Build query to find movies with similar genres\n    let query = `\n      SELECT id, title, poster_url, backdrop_url, release_year, rating, genre\n      FROM movies\n      WHERE 1=1\n    `;\n    \n    const params = [];\n    \n    // Add exclusion for watched movies\n    if (watchedIds.length > 0) {\n      const placeholders = watchedIds.map(() => \'?\').join(\',\');\n      query += ` AND id NOT IN (${placeholders})`;\n      params.push(...watchedIds);\n    }\n    \n    // Add genre conditions\n    if (genres.length > 0) {\n      query += \' AND (\';\n      const genreConditions = genres.map(() => \'genre LIKE ?\');\n      query += genreConditions.join(\' OR \');\n      query += \')\';\n      \n      genres.forEach(genre => {\n        params.push(`%${genre}%`);\n      });\n    }\n    \n    query += \' ORDER BY rating DESC LIMIT ?\';\n    params.push(parseInt(limit));\n    \n    // Execute query\n    const recommendations = await db.query(query, params);\n    \n    res.status(200).json({\n      error: false,\n      data: {\n        recommendations,\n        based_on: \'watch_history\'\n      }\n    });\n  } catch (err) {\n    console.error(\'Error fetching recommendations:\', err);\n    res.status(500).json({ error: true, message: \'Server error while fetching recommendations\' });\n  }\n});\n\nmodule.exports = router;\n</create-file>\n</function_calls>'}